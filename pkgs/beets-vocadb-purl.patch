diff --git a/beetsplug/vocadb/base.py b/beetsplug/vocadb/base.py
index 2d70d8f..a27562e 100644
--- a/beetsplug/vocadb/base.py
+++ b/beetsplug/vocadb/base.py
@@ -44,6 +44,8 @@ from beetsplug.vocadb.vocadb_api_client import (
     SongSortRule,
 )
 
+from mutagen import File
+
 if TYPE_CHECKING:
     from collections.abc import Iterable, Sequence
     from optparse import Values
@@ -498,22 +500,44 @@ class PluginBases:
                 sort=SongSortRule.SONG_TYPE,
                 lang=self.instance_config.language,
             )
-            remote_item_candidates: tuple[SongForApiContract, ...] | None
-            if not remote_item_find_result or not (
-                remote_item_candidates := remote_item_find_result.items
-            ):
+            remote_item_candidates: tuple[SongForApiContract, ...] = ()
+            if remote_item_find_result and remote_item_find_result.items:
+                remote_item_candidates = tuple(remote_item_find_result.items)
+            else:
                 self._log.debug(msg=f"Found 0 results for '{title}'")
-                return
+
+            f = File(item.path)
+            purl: str | None = None
+            if f is not None and (f.mime == ['audio/opus'] or f.__class__.__name__ == 'OggOpus'):
+                tags = getattr(f, 'tags', {})
+                if tags:
+                    purl = tags.get('PURL', [None])[0]
+
+            if purl:
+                self._log.debug(msg=f"PURL found, also searching by URL: {purl}")
+                purl_find_result = self.song_api.api_songs_get(
+                    query=purl,
+                    fields=SONG_FIELDS,
+                    maxResults=self.instance_config.search_limit,
+                    nameMatchMode=NameMatchMode.AUTO,
+                    preferAccurateMatches=True,
+                    sort=SongSortRule.SONG_TYPE,
+                    lang=self.instance_config.language,
+                )
+                if purl_find_result and purl_find_result.items:
+                    remote_item_candidates += tuple(purl_find_result.items)
+
             self._log.debug(
                 msg=f"Found {len(remote_item_candidates)} result(s) for '{title}'"  # pyrefly: ignore[unbound-name] # noqa: E501
             )
-            yield from filter(
-                None,
-                map(
-                    self.mapper.track_info,
-                    remote_item_candidates,  # pyrefly: ignore[unbound-name]
-                ),
-            )
+
+            seen_ids = set()
+            for candidate in remote_item_candidates:
+                candidate_id = getattr(candidate, "id", None)
+                if candidate_id in seen_ids:
+                    continue
+                seen_ids.add(candidate_id)
+                yield self.mapper.track_info(candidate)
 
         @override
         def album_for_id(self, album_id: str) -> AlbumInfo | None:
